{"version":3,"file":"crwl.cjs.production.min.js","sources":["../src/lib/page.ts"],"sourcesContent":["import {\n  Browser,\n  HTTPResponse,\n  Page as PuppeteerPage,\n  WaitForOptions,\n} from \"puppeteer\";\nimport { EventEmitter } from \"events\";\nimport { access, writeFile } from \"fs/promises\";\nimport { join } from \"path\";\nimport { AnyNode, Cheerio, load as cheerioLoad } from \"cheerio\";\nimport { URL } from \"url\";\nimport mkdirp from \"mkdirp\";\nimport { nanoid } from \"nanoid\";\n\n/**\n * Adding an exlucde array when there is an include array, does not do anything.\n */\nexport interface Schema {\n  rootElement?: string;\n  include?: string[];\n  exclude?: string[];\n}\n\nexport interface PageOptions {\n  baseUrl: string;\n  name?: string;\n  schema?: Schema;\n}\n\nexport interface PuppeteerBrowser extends Browser {}\n\nexport class Page extends EventEmitter {\n  protected _browser: PuppeteerBrowser;\n  protected _page: PuppeteerPage | null;\n  protected _options: PageOptions;\n  protected _root: Cheerio<AnyNode> | null;\n  protected _name: string;\n\n  constructor(browser: Browser, options: PageOptions) {\n    super();\n\n    this._browser = browser;\n    this._page = null;\n    this._options = options;\n    this._root = null;\n\n    this._name = options.name ?? \"Page-\" + nanoid(6);\n  }\n\n  get name() {\n    return this._name;\n  }\n\n  get root() {\n    return this._root;\n  }\n\n  get html() {\n    if (!this._root) return null;\n\n    return this._root.html();\n  }\n\n  public async open(\n    path: string,\n    options?: WaitForOptions\n  ): Promise<HTTPResponse | null> {\n    if (!this._page) {\n      this._page = await this._browser.newPage();\n    }\n\n    const url = new URL(path, this._options.baseUrl);\n\n    const res = await this._page.goto(url.href, options);\n\n    return res;\n  }\n\n  public async trimPage(\n    schema: Schema = this._options.schema || {}\n  ): Promise<string | null> {\n    if (!this._page) throw new Error(\"No page to trim.\");\n\n    // follow schema to trim the page down to the desired elements only\n\n    const pageSource = await this._page.content();\n    const $ = cheerioLoad(pageSource);\n\n    // get the root element that we are going to include/exclude tags from\n    const root = $(schema.rootElement ?? \"html\");\n\n    if (root.length < 0) {\n      throw new Error(\n        \"Could not find root element as specified in schema in page: \" +\n          this._options.name\n      );\n    }\n\n    this._root = root;\n\n    if (schema.include && schema.include.length > 0) {\n      // empty root to start including just the elements we want\n      const newRoot = root.clone().empty();\n\n      for (let elSelector of schema.include) {\n        const currentElement = root.find(elSelector);\n\n        newRoot.append(currentElement);\n      }\n\n      this._root = newRoot;\n    }\n\n    if (schema.exclude && schema.exclude.length > 0) {\n      // remove from current root\n      for (let elSelector of schema.exclude) {\n        this._root.find(elSelector).remove();\n      }\n    }\n\n    return this._root.html();\n  }\n\n  public async saveAs(filename: string, path: string = process.cwd()) {\n    if (!this._root) {\n      throw new Error(\n        \"No root element acquired yet. Trim page to get root element, then save page.\"\n      );\n    }\n    const html = this._root.html();\n    if (html === null) {\n      throw new Error(\"Could not get HTML string to save page.\");\n    }\n\n    try {\n      await access(path);\n    } catch (error) {\n      await mkdirp(path);\n    }\n\n    await writeFile(join(path, filename), html);\n  }\n}\n"],"names":["browser","options","_this","_browser","_page","_options","_root","_name","name","nanoid","_proto","open","path","this","_context","newPage","url","URL","baseUrl","href","trimPage","schema","_context2","Error","content","$","cheerioLoad","root","rootElement","length","include","newRoot","clone","empty","currentElement","find","append","exclude","remove","html","saveAs","filename","process","cwd","_context3","access","mkdirp","writeFile","join","key","get","EventEmitter"],"mappings":"w1PAsCE,WAAYA,EAAkBC,kBAC5BC,sBAEKC,SAAWH,EAChBE,EAAKE,MAAQ,KACbF,EAAKG,SAAWJ,EAChBC,EAAKI,MAAQ,KAEbJ,EAAKK,eAAQN,EAAQO,QAAQ,QAAUC,SAAO,qFAflD,sBAAA,OAAAC,EAgCeC,gBAhCf,kBAgCS,WACLC,EACAX,GAFK,MAAA,6BAAA,OAAA,sBAAA,OAAA,GAIAY,KAAKT,OAJLU,SAAA,MAAA,OAAAA,SAKgBD,KAAKV,SAASY,UAL9B,OAKHF,KAAKT,aALF,OAAA,OAQCY,EAAM,IAAIC,MAAIL,EAAMC,KAAKR,SAASa,SARnCJ,SAUaD,KAAKT,WAAWY,EAAIG,KAAMlB,GAVvC,OAAA,iCAAA,OAAA,UAAA,+BAhCT,OAAA,cAAA,mCAAAS,EA+CeU,oBA/Cf,kBA+CS,WACLC,GADK,sBAAA,6BAAA,OAAA,sBAAA,OAAA,YACLA,IAAAA,EAAiBR,KAAKR,SAASgB,QAAU,IAEpCR,KAAKT,OAHLkB,SAAA,MAAA,MAGkB,IAAIC,MAAM,oBAH5B,OAAA,OAAAD,SAOoBT,KAAKT,MAAMoB,UAP/B,OAAA,GAQCC,EAAIC,kBAGJC,EAAOF,WAAEJ,EAAOO,eAAe,SAE5BC,OAAS,IAbbP,UAAA,MAAA,MAcG,IAAIC,MACR,+DACEV,KAAKR,SAASG,MAhBf,QAsBL,GAFAK,KAAKP,MAAQqB,EAETN,EAAOS,SAAWT,EAAOS,QAAQD,OAAS,EAAG,CAI/C,IAFME,EAAUJ,EAAKK,QAAQC,YAENZ,EAAOS,wBACtBI,EAAiBP,EAAKQ,cAE5BJ,EAAQK,OAAOF,GAGjBrB,KAAKP,MAAQyB,EAGf,GAAIV,EAAOgB,SAAWhB,EAAOgB,QAAQR,OAAS,EAE5C,QAAuBR,EAAOgB,wBAC5BxB,KAAKP,MAAM6B,cAAiBG,SAtC3B,yBA0CEzB,KAAKP,MAAMiC,QA1Cb,QAAA,UAAA,+BA/CT,OAAA,YAAA,mCAAA7B,EA4Fe8B,kBA5Ff,kBA4FS,WAAaC,EAAkB7B,GAA/B,MAAA,6BAAA,OAAA,sBAAA,OAAA,YAA+BA,IAAAA,EAAe8B,QAAQC,OACtD9B,KAAKP,OADLsC,SAAA,MAAA,MAEG,IAAIrB,MACR,gFAHC,OAAA,GAOQ,QADPgB,EAAO1B,KAAKP,MAAMiC,SANnBK,SAAA,MAAA,MAQG,IAAIrB,MAAM,2CARb,OAAA,OAAAqB,SAAAA,SAYGC,SAAOjC,GAZV,OAAAgC,UAAA,MAAA,QAAA,OAAAA,UAAAA,gBAAAA,UAcGE,EAAOlC,GAdV,QAAA,OAAAgC,UAiBCG,YAAUC,OAAKpC,EAAM6B,GAAWF,GAjBjC,QAAA,UAAA,wCA5FT,OAAA,cAAA,4CAAAU,WAAAC,IAkBE,WACE,OAAOrC,KAAKN,SAnBhB0C,WAAAC,IAsBE,WACE,OAAOrC,KAAKP,SAvBhB2C,WAAAC,IA0BE,WACE,OAAKrC,KAAKP,MAEHO,KAAKP,MAAMiC,OAFM,oPA3BFY"}